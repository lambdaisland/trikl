(ns lambdaisland.trikl1.input-events
  "Parse and process events/commands received on the input stream, i.e.
  VT100/ANSI/etc escape codes."
  (:require [lambdaisland.trikl1.util :as util])
  (:import (java.lang Integer)
           (java.nio CharBuffer)))

(set! *warn-on-reflection* true)
(set! *unchecked-math* #_true :warn-on-boxed)

(def ESC \u001b)

(defn parse-cursor-pos
  "Given a cursor position control sequence as sent from the client, like ESC[80;20R,
  return [column row]. Note that we typically use this to infer the screen size,
  by first moving the cursor to a high col/row and then requesting the position.
  Also note that the order is column then row, as per Trikl conventions, even
  though the response is row;col. The result is also zero indexed."
  [csi]
  (when csi
    (when-let [[_ row col] (re-find #"(\d+);(\d+)R" csi)]
      [(dec (Integer/parseInt col))
       (dec (Integer/parseInt row))])))

(defn ansi-process-chars
  "Process input coming from the terminal connection. This can be simple input as
  entered on the keyboard and sent verbatim as characters, or it can be commands
  in the form of ANSI escape sequences. Commands are used to send size/resize
  messages, or to transmit special keys like arrow or function keys.

  This is an iterative function, it is meant to be called repeatedly, threading
  through a context which contains a buffer of characters to process. The
  dispatch function is called with input events or ansi command events.

  {:type :input :char ...}
  {:type :ansi :command ...}
  "
  [{:keys [^CharBuffer char-buf] :as ctx} dispatch]
  (if (not (.hasRemaining char-buf))
    ctx
    (let [ch (char (.get char-buf))
          ansi-state (:ansi-state ctx)]
      (cond
        ;; The ESC [ is followed by any number (including none) of "parameter
        ;; bytes" in the range 0x30–0x3F (ASCII 0–9:;<=>?), then by any number
        ;; of "intermediate bytes" in the range 0x20–0x2F (ASCII space and
        ;; !"#$%&'()*+,-./), then finally by a single "final byte" in the range
        ;; 0x40–0x7E (ASCII @A–Z[\]^_`a–z{|}~).
        ;;
        ;; We have a conundrum here, since we can't readily differentiate an ESC
        ;; coming from keyboard input, vs an ESC which is the start of an escape
        ;; sequence generated by the terminal emulator. We could look at the
        ;; next character to see if it looks like an escape sequence, but only
        ;; if the next character is already buffered.
        ;;
        ;; So if we are unsure we still initiate the escape sequence handling.
        ;; If we're unsure if more is coming then we also produce an :escape
        ;; keyboard event immediately. If we have more characters buffered we
        ;; continue processing, but generate an escape keyboard event if it
        ;; turns out what follows is not a valid escape sequence.
        (= ch (char ESC))
        (if (.hasRemaining char-buf)
          (assoc ctx
                 :esc-sent? false
                 :ansi-state :init
                 :ansi-command [])
          (do
            (dispatch {:type :input :char ch})
            (assoc ctx
                   :esc-sent? true
                   :ansi-state :init
                   :ansi-command [])))

        ;; ESC [ , continue parsing :param-bytes
        (and (= :init ansi-state) (= \[ ch))
        (-> ctx
            (assoc :ansi-state :param-bytes)
            (update :ansi-command conj ch))

        ;; ESC O , parse as function key sequence (F1 to F4)
        (and (= :init ansi-state) (= \O ch))
        (-> (assoc ctx :ansi-state :fn-key)
            (update :ansi-command conj ch))

        ;; continue escape sequence parsing, :param-bytes
        (and (= :param-bytes ansi-state) (util/char-in-range? \0 ch \?))
        (update ctx :ansi-command conj ch)

        ;; continue escape sequence parsing, switch to :interim-bytes
        (and (#{:param-bytes :interm-bytes} ansi-state) (util/char-in-range? \space ch \/))
        (-> (assoc ctx :ansi-state :interm-bytes)
            (update :ansi-command conj ch))

        (#{:param-bytes :interm-bytes :fn-key} ansi-state)
        (if (util/char-in-range? \@ ch \~)
          ;; finish escape sequence (terminating byte found)
          (do
            (dispatch {:type :ansi :command (String. (chars (into-array Character/TYPE (conj (:ansi-command ctx) ch))))})
            (dissoc ctx :ansi-state :ansi-command))

          ;; Turns out it wasn't an escape sequence, generate input events instead
          (do
            (when-not (:esc-sent? ctx)
              (dispatch {:type :input :char (char ESC)}))
            (doseq [ch (:ansi-command ctx)]
              (dispatch {:type :input :char ch}))
            (dispatch {:type :input :char ch})
            (dissoc ctx :ansi-state :ansi-command :esc-sent?)))

        ;; Not an escape sequence, treat as input
        :else
        (do
          (when (and (= :init ansi-state) (not (:esc-sent? ctx)))
            (dispatch {:type :input :char (char ESC)}))
          (dispatch {:type :input :char ch})
          (dissoc ctx :ansi-state :ansi-command :esc-sent?))))))

(def ansi-key-commands
  {"" :esc
   "[A" :up
   "[B" :down
   "[C" :right
   "[D" :left
   "[H" :home
   "[E" :end
   "[2~" :insert
   "[3~" :delete
   "OP" :f1
   "OQ" :f2
   "OR" :f3
   "OS" :f4
   "[15~" :f5
   "[17~" :f6
   "[18~" :f7
   "[19~" :f8
   "[20~" :f9
   "[21~" :f10
   "[23~" :f11
   "[24~" :f12})

(defn char->key [ch]
  (cond
    (= ESC ch)
    :escape

    (= \space ch)
    :space

    (= \return ch)
    :return

    (util/char-in-range? 0 ch 31)
    (keyword (str "ctrl-" (char (+ (long ch) 64))))

    (util/char-in-range? 33 ch 126)
    (keyword (str ch))

    (= ch \u007F)
    :backspace

    :else
    nil))

(defn semantic-message
  "Convert a message as dispatched by [[ansi-process-chars]] into higher level
  \"semantic\" messages."
  [{:keys [type command char] :as msg}]
  (case type
    :ansi
    (if-let [cursor-pos (parse-cursor-pos command)]
      (with-meta {:type :cursor-pos
                  :cursor cursor-pos}
        {:ansi/command command})
      (if-let [key (get ansi-key-commands command)]
        (with-meta {:type :input
                    :key key}
          {:ansi/command command})
        msg))

    :input
    (assoc msg :key (char->key (:char msg)))

    msg))
